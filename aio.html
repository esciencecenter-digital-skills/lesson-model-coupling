<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Model Coupling: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="manifest" href="site.webmanifest">
<link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md navbar-light bg-white top-nav incubator"><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-6">
      <div class="large-logo">
        <img alt="Carpentries Incubator" src="assets/images/incubator-logo.svg"><abbr class="icon" title="This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught." style="text-decoration: unset">
           
          <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#early-development-pre-alpha-through-alpha" class="external-link alert-link" style="color: #383838">Pre-Alpha
            <i aria-hidden="true" class="icon" data-feather="alert-octagon" style="color: #FF4955; border-radius: 5px"></i>
          </a>
          <span class="visually-hidden">This lesson is in the pre-alpha phase, which means that it is in early development, but has not yet been taught.</span>
        </abbr>
        
      </div>
    </div>
    <div class="selector-container ">
      
      
      <div class="dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl navbar-light bg-white bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Model Coupling
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
      <i role="img" aria-label="search button" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Model Coupling
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown"></ul>
</li>
      </ul>
</div>
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
<input class="form-control me-2 searchbox" type="search" placeholder="Search" aria-label="Search"><button class="btn btn-outline-success tablet-search-button" type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="search button"></i>
        </button>
      </fieldset>
</form>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Model Coupling
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
  <div id="sidebar-col" class="col-lg-4">
    <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle"><i class="search-icon" data-feather="x" role="img"></i></button>
        <div class="sidebar-inner">
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->
      
            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="01-introduction.html">1. Introduction to model coupling</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="02-theory.html">2. Model coupling theory: the Multiscale Modelling and Simulation Framework</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="03-muscle-connect.html">3. MUSCLE3 - connecting a model to MUSCLE</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="04-muscle-couple.html">4. MUSCLE3 - coupling and running</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>
                      
                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width resources">
<a href="aio.html">See all in one page</a>

            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">
            
            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-01-introduction"><p>Content from <a href="01-introduction.html">Introduction to model coupling</a></p>
<hr>
<p> Last updated on 2022-10-31 | 
        
        <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/edit/main/episodes/01-introduction.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right"> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is meant by a “model”?</li>
<li>What is the difference between a mathematical model and a computational model?</li>
<li>What is model coupling?</li>
<li>Why would we want to couple simulation models?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain the benefits of coupling simulation models</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Computer simulations are widely used in modern science to understand and predict the behaviour of natural systems. The computer program that simulates a given physical system is referred to as a <em>model</em> of that system. For example, a climate simulation code is a <em>model</em> of the Earth’s climate. Some models may be very simple e.g. describing the evolution of a 1 dimensional system. Others may be highly complex, involving many different physical processes. A well known use of computer simulation is in the field of weather forecasting, in which a very complex model composed of a multitude of different physical processes must be simulated by a computer program, generally requiring powerful supercomputers.</p>
</section><section id="mathematical-model-vs-computational-model"><h2 class="section-heading">Mathematical model vs computational model<a class="anchor" aria-label="anchor" href="#mathematical-model-vs-computational-model"></a>
</h2>
<hr class="half-width">
<p>For this course, it is important to distinguish between a <em>mathematical</em> model, and a <em>computational</em> model. A mathematical model refers to the set of mathematical equations that describe the evolution of a given physical system. The computational model refers to the actual computer program that describes the evolution of a physical system. These are closely connected concepts - after all, many computational models are just solving a given mathematical model numerically. However, the distinction is important. Some computational models can be simulating many different aspects of a physical system, which could involve solving many different mathematical models. The process of making sure that a computational model is solving the mathematical model you think it is, is called <em>verification</em>.</p>
</section><section id="what-is-model-coupling"><h2 class="section-heading">What is model coupling?<a class="anchor" aria-label="anchor" href="#what-is-model-coupling"></a>
</h2>
<hr class="half-width">
<p>In short, “coupling” one computational model to another means that we pass information between the models in order to connect them into one big model. If the output of one model can be used as the input of another, for example, then it may be possible to couple them. The models must of course be compatible - at least one model must calculate something that can be used by the other model.</p>
<div class="section level3">
<h3 id="an-example-making-a-coupled-model-of-a-flying-aeroplane">An example: Making a coupled model of a flying aeroplane<a class="anchor" aria-label="anchor" href="#an-example-making-a-coupled-model-of-a-flying-aeroplane"></a>
</h3>
<p>Imagine that we wish to simulate a flying aeroplane, but we only have two separate models: Model A and Model B.</p>
<figure><img src="fig/640px-DLR_2007_A380_sim_hires.jpg" alt="Computational fluid dynamics simulation of airflow over an aeroplane wing." class="figure mx-auto d-block"><figcaption>Computational fluid dynamics solver applied to A380 aircraft. (Image: DLR, CC-BY 3.0)</figcaption></figure><p>Model A simulates how an aeroplane moves in response to forces on its body. Model B simulates airflow around objects and calculates the forces generated by that airflow. We could pass the shape, speed and rotation of the airplane as input to Model B, allowing it to calculate the forces on the plane. In turn, we could then pass the calculated forces back to Model A, allowing it to calculate the effect of the forces on the plane’s speed, position and rotation. In this way we have <em>coupled</em> the two models together, making a new, more complex computational model. The two original models are <em>submodels</em> of the coupled model.</p>
<figure><img src="fig/ep01-plane-model-coupling.png" alt="One box labelled Model A and another box labelled Model B. There is an arrow between A and B showing transfer of plane shape. There is an arrow from B to A showing transfer of resulting airflow stresses." class="figure mx-auto d-block"><figcaption>Models A and B for the plane coupling example</figcaption></figure><div id="exercise-breaking-it-down" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-breaking-it-down" class="callout-inner">
<h3 class="callout-title">Exercise: Breaking it down<a class="anchor" aria-label="anchor" href="#exercise-breaking-it-down"></a>
</h3>
<div class="callout-content">
<p>Think of another system you might want to simulate. Can you think of how to break it down into two or more computational submodels? Most importantly, consider what information would be passed from one model to the other.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">
  Example solution
  </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>Local climate-ecology: One model simulates the expected climate of a region of the Earth under certain vegetation/land use conditions. A separate model simulates the proliferation and behaviour of animals and vegetation in a given region under influence of various climatic conditions.</li>
<li>Stent in a blood vessel: There is a computational fluid dynamics model (simulating the blood flow) through a stent. A separate model is modelling the growth of scar tissue, that covers the stent as the artery wall heals. The stresses created by the blood on the stent and tissue affect how it grows. In turn, the new, narrowed arterial wall needs to be passed back to the blood flow model, since new tissue will affect the flow.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section id="why-couple-models-together"><h2 class="section-heading">Why couple models together?<a class="anchor" aria-label="anchor" href="#why-couple-models-together"></a>
</h2>
<hr class="half-width">
<p>It is generally simpler and cheaper to simulate a small part of a system, or specific physical interaction. Processes at different length or time scales are often subject to different forces, while they can neglect others. For example, a mechanical model of a car frame will not consider behaviour at the atomic scale, whereas a molecular dynamics simulation naturally must. Computational modelling is therefore often highly specialised.</p>
<p>Furthermore, there can be an enormous number of different computational models even for the same problem, at the same length and time scales. Some models may be more accurate than others, or include newer theory etc. A scientist or engineer will combine different submodels together to run different computational experiments.</p>
<div id="why-bother-lets-just-have-one-big-model" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="why-bother-lets-just-have-one-big-model" class="callout-inner">
<h3 class="callout-title">Why bother? Let’s just have one big model<a class="anchor" aria-label="anchor" href="#why-bother-lets-just-have-one-big-model"></a>
</h3>
<div class="callout-content">
<p>Rather than couple existing models together, it is of course possible to simply create a single, monolithic model that handles all of the interactions within it. Can you think of reasons why we would not want to do that?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<ul>
<li>Code re-use: If a model already exists then ideally you should reuse it, rather than re-invent the wheel.</li>
<li>Separation of concerns: The submodel does ‘one thing and does it well’ (hopefully). The modularity of keeping code separate in this way can really help with long term maintenance of a large comple simulation model. This is particularly obvious when models simulate processes that happen on totally different and non-overlapping length and time scales.</li>
<li>Speed of building new models: If people can construct a complex model out of smaller, highly tested and optimised building blocks, then the task is a lot less laborious.</li>
<li>Ease of swapping new, different models in and out. If a new, faster or more accurate implementation of a model is released, you want to be able to swap out an existing submodel for it. Having everything in a single monolithic code can lead to a tangled mess that is harder to refactor. In many cases it will just not be worth the time to refactor the existing simulation code, and people will write a new one, or not try the new model at all.</li>
<li>Performance: A model coupling approach often makes it easier to exploit the massive parallelism of supercomputers.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Keypoints<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Crossing the scales</li>
<li>Modularity</li>
<li>Flexibility</li>
<li>Performance</li>
</ul>
</div>
</div>
</div>
<!-- 
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use. 
 -->
</section></section><section id="aio-02-theory"><p>Content from <a href="02-theory.html">Model coupling theory: the Multiscale Modelling and Simulation Framework</a></p>
<hr>
<p> Last updated on 2022-10-31 | 
        
        <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/edit/main/episodes/02-theory.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right"> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>When coupling models together, how do you figure out which information needs to be exchanged when?</li>
<li>How does that depend on the spatial and temporal scales of the simulated processes?</li>
<li>What does that mean for how submodels should be implemented?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Explain how to couple models using the concepts of the Multiscale Modelling and Simulation Framework</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Coupling models can be a difficult task, especially when there are many models involved that model processes in different ways and at different scales in time and space. To make a coupled simulation, you need to figure out which information needs to be passed between which submodels, when it needs to be sent and received, and how it can be represented, and that can be quite a puzzle. Fortunately, there is a theory of model coupling that can help you with this. It is called the Multiscale Modelling and Simulation Framework (MMSF), and despite its name, it also includes same-scale couplings.</p>
<p>In this episode, we’ll work through a slightly extended version of the MMSF’s process for coupling two models representing two processes.</p>
</section><section id="domains"><h2 class="section-heading">Domains<a class="anchor" aria-label="anchor" href="#domains"></a>
</h2>
<hr class="half-width">
<p>Mathematical and simulation models represent some kind of process, which takes place in a certain location in time and in space: its domain. The weather takes place in the atmosphere, earthquakes in the Earth’s crust, a forest fire in a forest. In time, that forest fire begins with a lightning strike and ends when the flames are extinguished, and even continuous processes like the airflow around an aeroplane wing can be considered to start when circumstances change and end when a steady state is reached again.</p>
<p>The domains of two models can be the <em>same</em>, <em>overlapping</em>, <em>adjacent</em>, or <em>separated</em>, in both space and time. This is important for the coupling between them, because it decides what is sent (state or boundary conditions) and when it is sent.</p>

<div id="challenge-1-models-and-domains" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-models-and-domains" class="callout-inner">
<h3 class="callout-title">Challenge 1: Models and domains<a class="anchor" aria-label="anchor" href="#challenge-1-models-and-domains"></a>
</h3>
<div class="callout-content">
<p>Think of two models that could potentially be coupled, and describe each model’s domain in time and space and the relation between them.</p>
<p>Some things to ponder:</p>
<ul>
<li>What does it mean for two models to have adjacent time domains?</li>
<li>What if their spatial domains are separated?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">
  Example solution
  </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="section level3">
<h3 id="example-coupled-model">Example coupled model<a class="anchor" aria-label="anchor" href="#example-coupled-model"></a>
</h3>
<p>The sun drives local convection in the atmosphere by heating up the Earth’s surface, which then heats up the air above it. We can model how this plays out over the course of a day by coupling two models:</p>
<p>Model 1 simulates the heating of the Earth’s surface as the sun shines on it. Model 2 simulates the flow of the air above as it warms up and starts rising. In time, both domains extend from sunrise to sunset. In space, the heating process takes place on the Earth’s surface, while the airflow process operates on the atmosphere. In time, the domains overlap, while in space they are adjacent.</p>
</div>
<div class="section level3">
<h3 id="questions">Questions<a class="anchor" aria-label="anchor" href="#questions"></a>
</h3>
<ul>
<li>If two models have adjacent time domains, then one model starts at the same moment that the other ends. Typically, this occurs when one process triggers another.</li>
<li>If the spatial domains of two models are separated, then there is no direct exchange of information between the models, unless some kind of remote communication is possible. As a result, the models can be run separately and don’t need to be coupled, unless some other model has a domain adjacent to both.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section id="scales"><h2 class="section-heading">Scales<a class="anchor" aria-label="anchor" href="#scales"></a>
</h2>
<hr class="half-width">
<p>A second important property of a physical process is the scales, again in time and in space, on which it takes place. A scale can be defined by its grain and extent. There are many other terms in use for these, but we’ll use these here because they’re less ambiguous than most. The <em>grain</em> refers to the smallest detail that the model can represent. In practice, that is usually set by the timestep (in time), grid spacing, or size of an agent (in space). If these can vary throughout the domain, pick the smallest. The <em>extent</em> refers to the size of the process in space and time, so the size of its domain. How long does it take to complete (or to reach a steady state), and how large an area is modelled?</p>

<div id="challenge-2-models-and-scales" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-models-and-scales" class="callout-inner">
<h3 class="callout-title">Challenge 2: Models and scales<a class="anchor" aria-label="anchor" href="#challenge-2-models-and-scales"></a>
</h3>
<div class="callout-content">
<p>What are the scales of the models you previously considered the domains of? What are their grain and extent in space and in time?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">
  Example solution
  </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<div class="section level3">
<h3 id="surface">Surface<a class="anchor" aria-label="anchor" href="#surface"></a>
</h3>
<p>Model 1 simulates the heating of the Earth’s surface as the sun shines on it.</p>
<p>The temperature of the Earth’s surface only changes slowly during the day, and we can probably say there are no significant changes from one minute to the next, or even for a somewhat larger interval. So the time grain of model 1 is on the order of a few minutes, perhaps up to an hour. The time extent of the model is one day, as it will repeat itself after that.</p>
<p>In space, the grain depends on the research question, and could be as small as 10 cm if we are looking at the detailed thermal environment around a building, or as large as a few kilometers if we want to make a national weather forecast. The extent is the size of the area of study.</p>
</div>
<div class="section level3">
<h3 id="atmosphere">Atmosphere<a class="anchor" aria-label="anchor" href="#atmosphere"></a>
</h3>
<p>Model 2 simulates the flow of the air above as it warms up and starts rising. This is probably done using a computational fluid dynamics model. Both the temporal and spatial scales will depend on the research question here, and grains (time steps and grid spacing) may range from milliseconds and centimeters to minutes and kilometers. The spatial extent may be the same as that of Model 1, but it could be larger if a very tall column of air is modeled. In time, the atmosphere won’t reach a static equilibrium, but we could choose to run the simulation for the course of a day and use that as the temporal extent.</p>
<p>Note that you often cannot give an exact number, and that the scales are often something of a modeling decision. That’s usually alright, as we will see below.</p>
</div>
</div>
</div>
</div>
</div>
<p>Just like with domains, the scales of two models can be compared and their relation determined. The Scale Separation Map (SSM) is a nice tool for this. The SSM is a graph with on its horizontal axis a range of durations, and on its vertical axis a range of sizes. Each model can then be plotted as a box, with the left edge at the temporal grain, the right edge at the temporal extent, the lower edge at the spatial grain, and the upper edge at the spatial extent. Here is an example:</p>
<figure><img src="fig/ep02-scale-separation-map.png" alt="2D plot with time on the horizontal axis and space on the vertical axis. In the center there is a box, which is surrounded by dashed boxes labelled a through h." class="figure mx-auto d-block"><figcaption>The Scale Separation Map. The box in the center depicts the scale of a given process or model, the dashed boxes show possible other scales and the corresponding relationships.</figcaption></figure><p>The SSM may look very counterintuitive at first, because we are used to plotting locations, not sizes. So look at the graph carefully and think about what you see and what it means. It does get easier to understand once you get the hang of it.</p>
<p>As you can see, we can plot multiple models on a Scale Separation Map and when we do, the map shows the relationship between the scales of two models. Both horizontally and vertically, model rectangles can have a gap between them (i.e. be separated), or be adjacent, or overlap, and the corresponding models are said to be scale separated, scale adjacent or scale overlapping in space and/or in time.</p>
<p>For coupling, it is actually only these relationships that matter. Even if you don’t know the exact grain or extent of a particular model, you can often decide whether it’s smaller, larger or the same as the grain or extent of another model and draw them correspondingly.</p>

<div id="challenge-3-scale-separation-map" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-scale-separation-map" class="callout-inner">
<h3 class="callout-title">Challenge 3: Scale Separation Map<a class="anchor" aria-label="anchor" href="#challenge-3-scale-separation-map"></a>
</h3>
<div class="callout-content">
<ul>
<li>What are the relations of scales a through h in the figure relative to the reference scale?</li>
<li>Draw a scale separation map for the models you would like to couple.</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3">
  Example solution
  </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<div class="section level3">
<h3 id="scale-relations">Scale relations<a class="anchor" aria-label="anchor" href="#scale-relations"></a>
</h3>
<ol style="list-style-type: lower-alpha">
<li>Spatially (larger) and temporally (faster) scale separated.</li>
<li>Spatially scale adjacent (larger), temporally scale overlapping.</li>
<li>Spatially scale adjacent (larger), temporally scale adjacent (larger).</li>
<li>Spatially scale overlapping, temporally scale adjacent (smaller).</li>
<li>Spatially scale overlapping, temporally scale separated (slower).</li>
<li>Spatially and temporally scale overlapping.</li>
<li>Spatially scale adjacent (smaller) and temporally scale separated (faster).</li>
<li>Spatially scale separated (smaller) and temporally scale adjacent (slower).</li>
</ol>
</div>
<div class="section level3">
<h3 id="scale-separation-map">Scale Separation Map<a class="anchor" aria-label="anchor" href="#scale-separation-map"></a>
</h3>
<figure><img src="fig/ep02-scale-separation-map-solution.png" alt="2D plot showing one large box for the atmosphere model, ranging from 1 second to 1 day and 10 cm to 100 m, and a smaller overlapping box for the surface heating model ranging from 10 mn to 1 day and 1m to 100m." class="figure mx-auto d-block"><figcaption>Scale Separation Map for the atmosphere/surface model.</figcaption></figure>
</div>
</div>
</div>
</div>
</div>
</section><section id="models-and-the-submodel-execution-loop"><h2 class="section-heading">Models and the Submodel Execution Loop<a class="anchor" aria-label="anchor" href="#models-and-the-submodel-execution-loop"></a>
</h2>
<hr class="half-width">
<p>So far, we have talked about domains and scales of models, which we can do based on the physical properties of the modelled system, and the research questions we ask about that system. In order to be able to technically couple models however, we need to know what a model is. In the MMSF, this is done using a universal model-of-a-model called the Submodel Execution Loop (SEL):</p>
<figure><img src="fig/ep02-submodel-execution-loop.png" alt="Diagram showing a diamond marked f init, a circle marked O i, another circle marked S, and another diamond marked O f connected by arrows in order. Another arrow loops back from S to O i. A dashed arrow points into f init, another dashed arrow points away from O i, another points into S and a fourth dashed arrow points away from O f. The circle marked O i and the diamond marked O f are white on black, the others black on white." class="figure mx-auto d-block"><figcaption>Submodel Execution Loop (SEL)</figcaption></figure><p>According to the MMSF, each model starts by initialising itself, a stage (or <em>operator</em>) known as <span class="math inline">\(f_{init}\)</span>. This puts the model into its initial state. During <span class="math inline">\(f_{init}\)</span>, information may be received from other models in a coupled simulation, which the model can use to initialise itself.</p>
<p>Second, some output based on that state is produced in the <span class="math inline">\(O_i\)</span> operator. This is <strong>i</strong>ntermediate Output, or, looking from the outside in, we Observe an <strong>i</strong>ntermediate state, hence <span class="math inline">\(O_i\)</span>. This output may be sent to other models, where it can for example be used as boundary conditions.</p>
<p>Third, a state update may be performed using the <span class="math inline">\(S\)</span> operator, which moves the model to its next state (timestep). During <span class="math inline">\(S\)</span>, information may be received from other models to help perform the state update.</p>
<p>After <span class="math inline">\(S\)</span>, the model may loop back to before <span class="math inline">\(O_i\)</span>, and repeat those two operators for a while, until the end of the time scale is reached. This leaves the model with a final state, which may be output in the <span class="math inline">\(O_f\)</span> operator (for <strong>f</strong>inal output or observation).</p>
<div id="callout1" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout<a class="anchor" aria-label="anchor" href="#callout1"></a>
</h3>
<div class="callout-content">
<p>Note that there’s a mnemonic here for the symbols: Operators <span class="math inline">\(O_i\)</span> and <span class="math inline">\(S\)</span>, which are within the state update loop, have a circular symbol, while <span class="math inline">\(f_{init}\)</span> and <span class="math inline">\(O_f\)</span> use a diamond shape. Also, filled symbols designate ports on which messages are sent, while open symbols designate receiving ports. Information must always be sent from an operator with a filled symbol to one with an open symbol.</p>
</div>
</div>
</div>
<p>This basic model is quite flexible. If the loop is run zero times, then the model is a simple function. Timesteps may be of any length, and vary during the run, and the model may decide to stop and exit the state update loop at any time. The state may represent anything at all in any way, and it may be updated in whichever way is suitable for the model. Any simulation code you may want to use is very likely to fit these minimal constraints.</p>
</section><section id="temporal-domain-and-scale-relations"><h2 class="section-heading">Temporal domain and scale relations<a class="anchor" aria-label="anchor" href="#temporal-domain-and-scale-relations"></a>
</h2>
<hr class="half-width">
<p>Now that we know what a model is and how models may be related in terms of their domains and scales, we can decide how to set up the coupled simulation. We do this by looking at all pairs of two models under consideration, one pair at a time, and consider the relationships between their temporal and spatial scales as well as their domains.</p>
<p>For reference, here are the possible relations between two time domains or two time scales:</p>
<table class="table">
<colgroup>
<col width="29%">
<col width="29%">
<col width="40%">
</colgroup>
<thead><tr class="header">
<th>Property</th>
<th>Relation</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Domain</td>
<td>Same</td>
<td>At the same time, acting on the exact same bit of reality</td>
</tr>
<tr class="even">
<td>Domain</td>
<td>Overlap</td>
<td>Some parts at the same time, acting on the same bit of reality</td>
</tr>
<tr class="odd">
<td>Domain</td>
<td>Adjacent</td>
<td>One starting precisely when the other ends</td>
</tr>
<tr class="even">
<td>Domain</td>
<td>Separated</td>
<td>One starting some time after the other ends</td>
</tr>
<tr class="odd">
<td>Scale</td>
<td>Same</td>
<td>Same grain (dt) and extent (duration)</td>
</tr>
<tr class="even">
<td>Scale</td>
<td>Overlap</td>
<td>Grain or extent differs, but neither model has a grain larger than the extent of the other or an extent smaller than the grain of the other</td>
</tr>
<tr class="odd">
<td>Scale</td>
<td>Adjacent</td>
<td>One model’s extent equals the other’s grain</td>
</tr>
<tr class="even">
<td>Scale</td>
<td>Separated</td>
<td>One model’s extent is smaller than the other model’s grain</td>
</tr>
</tbody>
</table>
<p>Of the different properties, those governing time are the most interesting, and also potentially the most confusing. Let’s look at the possible scenarios one by one.</p>
<div class="section level3">
<h3 id="adjacent-or-separated-time-domains">Adjacent or separated time domains<a class="anchor" aria-label="anchor" href="#adjacent-or-separated-time-domains"></a>
</h3>
<p>A simple case is when the time domains are adjacent, meaning one process starts right when the other process finishes, or separated, meaning one process starts some time after the other process finishes. In this case, the final output of the first model is used to initialise the subsequent model.</p>
</div>
<div class="section level3">
<h3 id="same-time-domains-and-the-same-temporal-scale">Same time domains and the same temporal scale<a class="anchor" aria-label="anchor" href="#same-time-domains-and-the-same-temporal-scale"></a>
</h3>
<p>If two processes do not happen one after the other, then they occur at least partially simultaneously, and their models have overlapping time domains. The simplest among these cases is when the two processes start and end at the same time, and have the same timestep. In that case, each model updates its state to the next timestep, then sends some information based on the new state (e.g. boundary conditions) to the other model, receives information from the other model in return, and goes to do the next state update.</p>
</div>
<div class="section level3">
<h3 id="same-time-domains-and-temporal-scale-separation">Same time domains and temporal scale separation<a class="anchor" aria-label="anchor" href="#same-time-domains-and-temporal-scale-separation"></a>
</h3>
<p>A third interesting case is when two processes happen at the same time, but one process is much faster than the other, so that it runs to completion in (much) less time than it takes the other to do a timestep. In that case, the fast model needs to do an entire run for every timestep of the slow model.</p>
<div id="challenge-4-coupling-submodel-execution-loops" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-coupling-submodel-execution-loops" class="callout-inner">
<h3 class="callout-title">Challenge 4: Coupling Submodel Execution Loops<a class="anchor" aria-label="anchor" href="#challenge-4-coupling-submodel-execution-loops"></a>
</h3>
<div class="callout-content">
<p>We can represent each of the two models in the scenarios above as a Submodel Execution Loop. To connect the models, we then have to send information between the operators of the models. For each of the three cases, figure out how to connect the Submodel Execution Loops of the two models so that the correct communication pattern is implemented.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4">
  Example solution
  </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>If the time domains are adjacent or separated, then the final output of the first model is used to initialise the subsequent model. We can implement this by sending information from the first model’s <span class="math inline">\(O_f\)</span> to the second model’s <span class="math inline">\(f_{init}\)</span>.</p>
<p>If the temporal scales are the same, then the models exchange information every time they have a new state. This can be done by connecting each model’s <span class="math inline">\(O_i\)</span> to the other model’s <span class="math inline">\(S\)</span>, thus sending information at each step.</p>
<p>In case of temporal scale separation, the fast model needs to be reinitialised at every timestep of the slow model, do an entire run, and return some information based on its final state to the slow model. This can be accomplished by sending from the slow model’s <span class="math inline">\(O_i\)</span> to the fast model’s <span class="math inline">\(f_{init}\)</span> and from the fast model’s <span class="math inline">\(O_f\)</span> back to the slow model’s <span class="math inline">\(S\)</span>.</p>
</div>
</div>
</div>
</div>
</div>
</section><section id="coupling-templates"><h2 class="section-heading">Coupling Templates<a class="anchor" aria-label="anchor" href="#coupling-templates"></a>
</h2>
<hr class="half-width">
<figure><img src="fig/ep02-coupling-templates.png" alt="Three diagrams of the coupling templates. Each diagram shows two submodel execution loops. The first diagram is titled Dispatch. In it, O_F on the first SEL is connected to F_INIT on the second SEL. The second diagram is titled Interact. In it, O_I on each SEL is connected to S on the other. The third diagram is titled Call and Release. O_I on the first SEL is connected to F_INIT on the second, this is Call. O_F on the second SEL is connected to S on the first, this is Release." class="figure mx-auto d-block"><figcaption>Coupling Templates</figcaption></figure><p>The three cases above demonstrate the four <em>Coupling Templates</em> defined by the MMSF. The first one, <span class="math inline">\(O_f\)</span> to <span class="math inline">\(f_{init}\)</span>, is called <em>dispatch</em>. The second one, <span class="math inline">\(O_i\)</span> to <span class="math inline">\(S\)</span> is called <em>interact</em>, and usually comes in pairs. The third one and the fourth one usually go together, as the combination <em>call</em> (<span class="math inline">\(O_i\)</span> to <span class="math inline">\(f_{init}\)</span>) and <em>release</em> (<span class="math inline">\(O_f\)</span> to <span class="math inline">\(S\)</span>).</p>
<p>Given the constraints of which operators can send and which can receive, these are in fact all four possible types of connections, and between them they cover all kinds of temporal scale relations.</p>
<p>If the time domains or time scales overlap, but are not equivalent, then an additional component is needed that sits between the models; we will not go into that advanced use case here.</p>
</section><section id="spatial-domains-scales-and-multiplicity"><h2 class="section-heading">Spatial domains, scales and multiplicity<a class="anchor" aria-label="anchor" href="#spatial-domains-scales-and-multiplicity"></a>
</h2>
<hr class="half-width">
<p>Having discussed temporal scales, let’s move on to the spatial scales. Like with scales in time, scales in space can be the same, overlap, be adjacent or be separated, and you can see which one you have by looking at your Scale Separation Map. Here’s another table with the interpretation of those relations in space:</p>
<table class="table">
<colgroup>
<col width="29%">
<col width="29%">
<col width="40%">
</colgroup>
<thead><tr class="header">
<th>Property</th>
<th>Relation</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Domain</td>
<td>Same</td>
<td>In the same place, acting on the exact same bit of reality</td>
</tr>
<tr class="even">
<td>Domain</td>
<td>Overlap</td>
<td>Some parts in the same place, acting on the same bit of reality</td>
</tr>
<tr class="odd">
<td>Domain</td>
<td>Adjacent</td>
<td>Acting on two different bits of reality which touch each other (space)</td>
</tr>
<tr class="even">
<td>Domain</td>
<td>Separated</td>
<td>Acting on two different bits of reality which do not touch (space)</td>
</tr>
<tr class="odd">
<td>Scale</td>
<td>Same</td>
<td>Same grain (dx) and extent (size)</td>
</tr>
<tr class="even">
<td>Scale</td>
<td>Overlap</td>
<td>Grain or extent differs, but neither model has a grain larger than the extent of the other or an extent smaller than the grain of the other</td>
</tr>
<tr class="odd">
<td>Scale</td>
<td>Adjacent</td>
<td>One model’s extent equals the other’s grain</td>
</tr>
<tr class="even">
<td>Scale</td>
<td>Separated</td>
<td>One model’s extent is smaller than the other model’s grain</td>
</tr>
</tbody>
</table>
<div class="section level3">
<h3 id="same-spatial-domain-and-scale">Same spatial domain and scale<a class="anchor" aria-label="anchor" href="#same-spatial-domain-and-scale"></a>
</h3>
<p>This is a very tight coupling, where usually the two processes end up in a single equation on the theory side, and in a single code in the implementation. Unless there is temporal scale separation, it’s probably better to combine the models into a single implementation. In case of temporal scale separation, a call-and-release template may be used and the state is passed back and forth between the models.</p>
</div>
<div class="section level3">
<h3 id="same-spatial-domain-adjacent-or-separated-scales">Same spatial domain, adjacent or separated scales<a class="anchor" aria-label="anchor" href="#same-spatial-domain-adjacent-or-separated-scales"></a>
</h3>
<p>If one process is much smaller than the other, then the entire small process takes place within one grid cell or agent of the larger process. Frequently, this means that there are multiple instances of the smaller model, maybe even one for each grid cell or agent, with communication between the large-scale model and each small-scale model instance. Some kind of iterative equilibration between the models may be needed to reconcile the two representations of the state.</p>
</div>
<div class="section level3">
<h3 id="adjacent-spatial-domains-same-or-overlapping-spatial-scales">Adjacent spatial domains, same or overlapping spatial scales<a class="anchor" aria-label="anchor" href="#adjacent-spatial-domains-same-or-overlapping-spatial-scales"></a>
</h3>
<p>If two processes are of similar size and resolution, but occur on adjacent domains, then they will each have their own state, and exchange boundary conditions. If there’s a temporal scale separation between them, then the call-and-release coupling template is used and the called (fast) model keeps its state in between calls.</p>
<div id="challenge-5-spatial-relations" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-5-spatial-relations" class="callout-inner">
<h3 class="callout-title">Challenge 5: Spatial relations<a class="anchor" aria-label="anchor" href="#challenge-5-spatial-relations"></a>
</h3>
<div class="callout-content">
<p>Think of an example for each of the above spatial domain and scale relations. Can you think of examples that don’t fit any of them?</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5">
  Example solution
  </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" aria-labelledby="headingSolution5" data-bs-parent="#accordionSolution5">
<div class="accordion-body">
<ul>
<li>Reaction-diffusion models have the two processes acting on the same domain and spatial scale, but may be temporally scale-separated depending on parameter values.</li>
<li>A crack propagation model coupling a continuum representation of a material sample to molecular mechanics models at specific points. Stresses and strains are exchanged in this case.</li>
<li>In a simulation of In-Stent Restenosis, a complication of vascular surgery, a cell growth process in the wall of an artery is coupled with a fluid dynamics simulation of the blood flow through the artery. The domains are adjacent and boundary conditions are exchanged.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section id="mmsl-diagrams"><h2 class="section-heading">MMSL Diagrams<a class="anchor" aria-label="anchor" href="#mmsl-diagrams"></a>
</h2>
<hr class="half-width">
<p>For larger coupled simulations consisting of several submodels and other components, drawing the complete submodel execution loop as we did above gets too complicated. Fortunately, a simplified notation is available in the form of the Multiscale Modelling and Simulation Language (MMSL). This language describes a coupled simulation as a set of components and the connections between them. Its YAML-based form, yMMSL, is used as the configuration language for MUSCLE3 (more on which in the next episodes). Its graphical form, gMMSL, provides a compact visual representation of a coupled model:</p>
<figure><img src="fig/ep02-coupling-templates-mmsl.png" alt="Three diagrams of the coupling templates, this time in gMMSL. Each diagram shows two boxes. The top diagram is labelled dispatch and has the boxes labeled First and Second. A line connects a filled diamond on the box labelled first to an open diamond on the box labelled second. The bottom left diagram is labelled interact and has the boxes labeled A and B. A line connects a filled circle on box A to an open circle on box B, and another line connects a closed circle on box B to an open circle on box A. The bottom right diagram is labelled Call and Release. Its boxes are labelled Macro and Micro. A line connects a closed circle on Macro to an open diamond on Micro, and another line connects a filled diamond on Micro to an open circle on Macro. The box labeled Micro additionally has the number 10 written in its top right corner." class="figure mx-auto d-block"><figcaption>Coupling Templates in gMMSL</figcaption></figure><div id="challenge-6-deciphering-gmmsl" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-6-deciphering-gmmsl" class="callout-inner">
<h3 class="callout-title">Challenge 6: Deciphering gMMSL<a class="anchor" aria-label="anchor" href="#challenge-6-deciphering-gmmsl"></a>
</h3>
<div class="callout-content">
<p>Explain the above figure.</p>
</div>
</div>
</div>
<div id="accordionSolution6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution6" aria-expanded="false" aria-controls="collapseSolution6">
  <h4 class="accordion-header" id="headingSolution6">
  Example solution
  </h4>
</button>
<div id="collapseSolution6" class="accordion-collapse collapse" aria-labelledby="headingSolution6" data-bs-parent="#accordionSolution6">
<div class="accordion-body">
<p>Each box represents a submodel. The lines show where information is sent from one model to another. The diamonds and circles designate the SEL operators that information is sent from and to. A number in the top right corner of a box is optional, but when it’s there it shows how many instances of that submodel exist. In this case, the model at the bottom right has temporal and spatial scale separation, so it uses the call-and-release coupling template and has multiple instances of the micromodel.</p>
</div>
</div>
</div>
</div>
<p>Note that there can be multiple lines or <em>conduits</em> between the same operators and models if multiple bits of information need to be transferred, but then these could also be glued together into a single message. This is a modelling decision, so do what works best for your model.</p>
<p>Not shown in the diagram is that the lines can be labeled with a label at each end showing the name of the <em>port</em> on the model that is being connected. Especially if there are multiple lines then it is necessary to do that to avoid confusion. More about this in the following episodes, when we connect two models using MUSCLE3.</p>
<div id="callout2" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Callout<a class="anchor" aria-label="anchor" href="#callout2"></a>
</h3>
<div class="callout-content">
<p>Real simulations often need more than just the submodels, especially if you want to keep everything nice and modular. Different models often send and receive data in different formats for example, so that you need converters, and sometimes splitters and joiners that can split messages or join them together. If there is a scale difference, then some kind of scale bridge usually needs to be implemented, and for uncertainty quantification components may be needed that sample parameters and combine results into distributions.</p>
<p>These components are often simple functions, and can then be implemented just like a submodel with only an <span class="math inline">\(f_{init}\)</span> and <span class="math inline">\(O_f\)</span>. Such a component can then be inserted in between a connection between two submodels by interrupting a conduit and putting it in between.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Keypoints<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Physical processes take place on a domain and at certain scales in time and space</li>
<li>Simulation models are described by the Submodel Execution Loop</li>
<li>Given two models and their domains and scales, we can decide which coupling template to use to connect them</li>
<li>An MMSL diagram can be used to visualise a complete coupled simulation</li>
</ul>
</div>
</div>
</div>
<!-- 
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use. 
 -->
</section></section><section id="aio-03-muscle-connect"><p>Content from <a href="03-muscle-connect.html">MUSCLE3 - connecting a model to MUSCLE</a></p>
<hr>
<p> Last updated on 2022-10-31 | 
        
        <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/edit/main/episodes/03-muscle-connect.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right"> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do you connect an existing python model code to MUSCLE3?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Identify the inputs and outputs of your submodel and link them to ports</li>
<li>Recognize the Submodel Execution Loop structure in your code</li>
<li>Learn to connect a simple model to the MUSCLE3 library</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>MUSCLE3 is the third incarnation of the Multiscale Coupling Library and Environment. MUSCLE and the MMSF were developed at the University of Amsterdam Computational Science Lab, and MUSCLE3 is the result of a collaboration with the Netherlands eScience Center. MUSCLE3’s purpose is to make creating coupled multiscale simulations easy. MUSCLE3 uses the Multiscale Modelling and Simulation Language (MMSL) to describe the structure of a multiscale model, and you will notice that the terminology in MUSCLE3 closely links to what you have learned in the previous episode about MMSF.</p>
<p>In this episode, we will be connecting a small model to MUSCLE3, so that we can connect it to a second model in the next episode.</p>
<div class="section level3">
<h3 id="reaction-diffusion-model">Reaction-diffusion model<a class="anchor" aria-label="anchor" href="#reaction-diffusion-model"></a>
</h3>
<p>The example model for this course is a 1-dimensional reaction-diffusion model. This model models a 1-dimensional medium in which some chemical is constantly destroyed by a reaction, while it is also diffusing through the medium. A reaction submodel models exponential growth (or decline in this case, with a negative parameter) for each cell in the 1D grid. A diffusion submodel models diffusion through the 1D grid. This model is not very realistic, but we’re interested in the coupling, not in reaction-diffusion dynamics, so the simpler the better.</p>
<p>Reaction-diffusion models are a traditional example case for multiscale modelling because depending on the parameters used, they may be time-scale overlapping, adjacent or separated. In this example, we’re going to configure the diffusion model to be much slower than the reaction model, resulting in temporal scale separation.</p>
<p>To find out how to connect the models, we need to apply the MMSF to this particular situation. The reaction and diffusion processes act simultaneously on the same spatial and temporal domain. The discretisation of that domain in space is also the same for the two models, so that they have the same spatial scale. And there is temporal scale separation. According to the MMSF, that means that we have to use the Call-and-Release coupling template, with one instance of each submodel:</p>
<figure><img src="fig/ep03-reaction-diffusion-coupling.png" alt="gMMSL diagram for the reaction-diffusion model. Two boxes labeled macro and micro represent the two submodels. A line connects a filled circle labeled state_out on macro to an open diamond labeled state_in on micro. A second line connects a filled diamond labeled final_state on micro to an open circle labeled state_in on macro." class="figure mx-auto d-block"><figcaption>gMMSL diagram for the reaction-diffusion model</figcaption></figure><p>As you can see, each model will send and receive data on two operators, and we will connect them together as shown to form the full simulation.</p>
</div>
<div class="section level3">
<h3 id="muscle3">MUSCLE3<a class="anchor" aria-label="anchor" href="#muscle3"></a>
</h3>
<p>Before we can create our coupled simulation however, we will need to connect each submodel to MUSCLE3. MUSCLE3 consist of three components:</p>
<p><strong>libmuscle</strong> is a library that is used to connect component intances (e.g new or existing submodels) to a coupled simulation.</p>
<p><strong>muscle_manager</strong> is the central manager of MUSCLE3 that starts up submodels and coordinates their interaction.</p>
<p><strong>ymmsl-python</strong> is a Python library that contains class definitions to represent an MMSL model description. A yMMSL file serves as the interface between us (humans) and the muscle manager and is meant to describe the multiscale simulation and tell the muscle manager what to do.</p>
<p>Here, we will connect the reaction submodel (the micromodel) to the <code>libmuscle</code> library step by step. We’ll use yMMSL and the manager in the next episode.</p>
</div>
</section><section id="dissect-your-model"><h2 class="section-heading">Dissect your model<a class="anchor" aria-label="anchor" href="#dissect-your-model"></a>
</h2>
<hr class="half-width">
<p>Open the file called <code>reaction.py</code> from the data folder that you downloaded in the setup section in a text editor. It contains a function called <code>reaction</code> that requires a <code>numpy.array</code> as input and returns another after doing some operations.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reaction(initial_state: np.array) <span class="op">-&gt;</span> np.array:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    ...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    t_max <span class="op">=</span> <span class="fl">2.469136e-6</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> <span class="fl">2.469136e-8</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="op">-</span><span class="fl">4.05e4</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> initial_state.copy()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    t_cur <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> t_cur <span class="op">+</span> dt <span class="op">&lt;</span> t_max:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> k <span class="op">*</span> U <span class="op">*</span> dt</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        t_cur <span class="op">+=</span> dt</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code></pre>
</div>
<p>The function starts with defining some parameters that are used for the calculations in the main <code>while</code> loop. The <code>initial_state</code> is copied to a new working state <code>U</code> before the simulation starts.</p>
<div id="why-.copy" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="why-.copy" class="callout-inner">
<h3 class="callout-title">Why .copy()?<a class="anchor" aria-label="anchor" href="#why-.copy"></a>
</h3>
<div class="callout-content">
<p>Instead of using <code>.copy()</code>, we could also just assign <code>U</code> to equal the initial state (e.g. <code>U = initial_state</code>). For this particular example it would not matter since we do not use <code>initial_state</code> anymore. But if we did that, we would change the contents of <code>initial_state</code> every time we do an operation on <code>U</code>, because both variables would point to the same object. Since the variable is called <code>initial_state</code> it would be very confusing if it would change during the model execution. When you want to expand or change the model later on, it can be dangerous if variables do not behave as their name suggests.</p>
</div>
</div>
</div>
<p>At every iteration of the loop, the state <code>U</code> is updated by adding a fraction of the old state, scaled by the parameter k and the size of a time step. Also the time counter <code>t_cur</code> is incremented with one time step. The <code>while</code> loop continues to run until <code>t_cur</code> has reached the value of the parameter <code>t_max</code>. Finally, when it exits the loop, the function returns the updated state <code>U</code>.</p>
<div id="challenge-1-can-you-recognize-the-submodel-execution-loop" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-can-you-recognize-the-submodel-execution-loop" class="callout-inner">
<h3 class="callout-title">Challenge 1: Can you recognize the Submodel Execution Loop?<a class="anchor" aria-label="anchor" href="#challenge-1-can-you-recognize-the-submodel-execution-loop"></a>
</h3>
<div class="callout-content">
<p>In the previous episode we have discussed the Submodel Execution Loop (SEL) and the various operators that are associated with it. In the code of the <code>reaction</code> function, can you recognize the beginning and end of the four operators (<span class="math inline">\(f_{init}\)</span>, <span class="math inline">\(O_i\)</span>, <span class="math inline">\(S\)</span> and <span class="math inline">\(O_f\)</span> ) plus the state update loop in this submodel? Mark these by placing the following 10 comments in the code:</p>
<ul>
<li><code># begin F_INIT</code></li>
<li><code># end F_INIT</code></li>
<li><code># begin O_I</code></li>
<li><code># end O_I</code></li>
<li><code># begin S</code></li>
<li><code># end S</code></li>
<li><code># begin state_update_loop</code></li>
<li><code># end state_update_loop</code></li>
<li><code># begin O_F</code></li>
<li><code># end O_F</code></li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reaction(initial_state: np.array) <span class="op">-&gt;</span> np.array:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    ...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># begin F_INIT</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    t_max <span class="op">=</span> <span class="fl">2.469136e-6</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> <span class="fl">2.469136e-8</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="op">-</span><span class="fl">4.05e4</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> initial_state</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    t_cur <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># end F_INIT</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># begin state_update_loop</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> t_cur <span class="op">+</span> dt <span class="op">&lt;</span> t_max:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin O_I</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end O_I</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin S</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> k <span class="op">*</span> U <span class="op">*</span> dt</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        t_cur <span class="op">+=</span> dt</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end S</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># end state_update_loop</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># begin O_F</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># end O_F</span></span></code></pre>
</div>
<p><span class="math inline">\(f_{init}\)</span> is where everything gets initialised, at the top of the function. This is not just the state, but also parameters and helper variables. Then, the Submodel Execution Loop specifies two operators within the state update loop. <span class="math inline">\(O_i\)</span> comes before <span class="math inline">\(S\)</span> and you can use it to send information to the outside world with (part of) the current state. <span class="math inline">\(O_i\)</span> is empty here, because this original model didn’t produce any output for each state. It did update its state however, so that part of the code is in <span class="math inline">\(S\)</span>. Finally, returning a result falls under <span class="math inline">\(O_f\)</span>.</p>
</div>
</div>
</div>
</div>
</section><section id="creating-an-instance-object"><h2 class="section-heading">Creating an Instance object<a class="anchor" aria-label="anchor" href="#creating-an-instance-object"></a>
</h2>
<hr class="half-width">
<p>To let a model communicate with the muscle manager, other submodels and the outside world, we need to create a <code>libmuscle.Instance</code> object. An instance is a running submodel, and the Instance object represents this particular instance to MUSCLE3:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle <span class="im">import</span> Instance</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ymmsl <span class="im">import</span> Operator</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> some_example_submodel():</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    instance <span class="op">=</span> Instance({</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            Operator.F_INIT: [<span class="st">'initial_state_a'</span>, <span class="st">'initial_state_b'</span>],</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            Operator.O_I: [<span class="st">'some_intermediate_state'</span>],</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            Operator.S: [<span class="st">'some_other_intermediate_state'</span>],</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            Operator.O_F: [<span class="st">'final_state_a'</span>, <span class="st">'final_state_b'</span>]})</span></code></pre>
</div>
<p>The constructor takes a single argument, a dictionary that maps <code>ymmsl.Operator</code> objects to lists of ports. Ports are used to communicate with other simulation components. They have a name, and they are associated with a Submodel Execution Loop operator, which determines whether they are input or output ports. The operator that they are mapped to determines how the port is used, as explained in the previous episode. The names of the available operators correspond to their theoretical counterparts (<span class="math inline">\(f_{init}\)</span>, <span class="math inline">\(O_i\)</span>, <span class="math inline">\(S\)</span> and <span class="math inline">\(O_f\)</span> ).</p>
<div id="what-ports-do-we-need" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="what-ports-do-we-need" class="callout-inner">
<h3 class="callout-title">What ports do we need?<a class="anchor" aria-label="anchor" href="#what-ports-do-we-need"></a>
</h3>
<div class="callout-content">
<p>Question: In our example of the reaction submodel, what ports do we need to communicate the model state to the outside world? Come up with good names. What operators would we need to map them to?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>In this model, we need:</p>
<ul>
<li>a single input port that will receive an initial state (e.g. named “initial_state”) at the beginning of the model run and it should be mapped to the <span class="math inline">\(f_{init}\)</span> operator</li>
<li>a single output port that sends the final state (e.g. named “final_state”) at the end of the reaction simulation to the rest of the simulation, it should be mapped to the <span class="math inline">\(O_f\)</span> operator</li>
</ul>
</div>
</div>
</div>
</div>
</section><section id="the-reuse-loop"><h2 class="section-heading">The reuse loop<a class="anchor" aria-label="anchor" href="#the-reuse-loop"></a>
</h2>
<hr class="half-width">
<p>In multiscale coupled simulations, submodels often have to run multiple times, for instance because they are used as a micro model or because they are part of an ensemble that cannot be completely parallelised. To make this possible, we will wrap the entire submodel in a loop, the so-called reuse loop. Exactly when this loop needs to end often depends on the behaviour of the whole model, and is not easy to determine in advance, but fortunately MUSCLE will do that for us if we call the <code>Instance.reuse_instance()</code> method.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> instance.reuse_instance():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="co"># F_INIT</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># State update loop</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># O_F</span></span></code></pre>
</div>
<div id="challenge-2-creating-an-instance-and-adding-a-loop" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-creating-an-instance-and-adding-a-loop" class="callout-inner">
<h3 class="callout-title">Challenge 2: Creating an Instance and adding a loop<a class="anchor" aria-label="anchor" href="#challenge-2-creating-an-instance-and-adding-a-loop"></a>
</h3>
<div class="callout-content">
<p>Add the following to our reaction model code:</p>
<ul>
<li>a <code>libmuscle.Instance</code> object with the appropriate operator-port dictionary</li>
<li>the reuse loop</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle <span class="im">import</span> Instance</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ymmsl <span class="im">import</span> Operator</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reaction(initial_state: np.array) <span class="op">-&gt;</span> np.array:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ...</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    instance <span class="op">=</span> Instance({</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            Operator.F_INIT: [<span class="st">'initial_state'</span>],       <span class="co"># np.array</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            Operator.O_F: [<span class="st">'final_state'</span>]})           <span class="co"># np.array</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> instance.reuse_instance():</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin F_INIT</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        t_max <span class="op">=</span> <span class="fl">2.469136e-6</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        dt <span class="op">=</span> <span class="fl">2.469136e-8</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="op">-</span><span class="fl">4.05e4</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> initial_state</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        t_cur <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end F_INIT</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin state_update_loop</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> t_cur <span class="op">+</span> dt <span class="op">&lt;</span> t_max:</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># begin O_I</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="co"># end O_I</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># begin S</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> k <span class="op">*</span> U <span class="op">*</span> dt</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            t_cur <span class="op">+=</span> dt</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># end S</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end state_update_loop</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin O_F</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end O_F</span></span></code></pre>
</div>
<p>Note that the type of data that is sent is documented in a comment. This is obviously not required, but it makes life a lot easier if someone else needs to use the code or you haven’t looked at it for a while, so it’s highly recommended. MUSCLE3 does not require you to fix the type of the messages you’re sending to a port in advance; in principle you could send a different type of message every time you send something. The latter is a bad idea, but the flexibility makes development much easier.</p>
</div>
</div>
</div>
</div>
</section><section id="settings"><h2 class="section-heading">Settings<a class="anchor" aria-label="anchor" href="#settings"></a>
</h2>
<hr class="half-width">
<p>Next is the first part of the model, in which the model is initialised. Nearly every model needs some settings that define how it behaves (e.g. the size of a timestep or model specific parameters). With MUSCLE, we can specify settings for each submodel in a central configuration file, and get those settings from <code>libmuscle</code> in the model code. This way, we don’t have to change our model code every time if we want to try a range of values (for instance, to perform a sensitivity analysis). We can use the <code>Instance.get_setting</code> function instead to ask the MUSCLE manager for the values. Putting the values in the configuration file will be covered in the next episode, here we’ll look at how to get them from <code>libmuscle</code>.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    some_variable <span class="op">=</span> instance.get_setting(<span class="st">'variable_name'</span>, <span class="st">'variable_type'</span>)</span></code></pre>
</div>
<div id="type-checking" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="type-checking" class="callout-inner">
<h3 class="callout-title">Type checking<a class="anchor" aria-label="anchor" href="#type-checking"></a>
</h3>
<div class="callout-content">
<p>The second argument, which specifies the expected type, is optional. If it is given, MUSCLE will check that the user specified a value of the correct type, and if not raise an exception.</p>
</div>
</div>
</div>
<div id="challenge-3" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3" class="callout-inner">
<h3 class="callout-title">Challenge 3:<a class="anchor" aria-label="anchor" href="#challenge-3"></a>
</h3>
<div class="callout-content">
<p>In our example, several settings have been hard-coded into the model:</p>
<ul>
<li>the total simulation time to run this sub-model, <code>t_max</code>
</li>
<li>the time step to use, <code>dt</code>
</li>
<li>and the model parameter, <code>k</code>
</li>
</ul>
<p>Change the code such that we request these settings from the MUSCLE manager.</p>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" data-bs-parent="#accordionSolution4" aria-labelledby="headingSolution4">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle <span class="im">import</span> Instance</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ymmsl <span class="im">import</span> Operator</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reaction(initial_state: np.array) <span class="op">-&gt;</span> np.array:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ...</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    instance <span class="op">=</span> Instance({</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            Operator.F_INIT: [<span class="st">'initial_state'</span>],       <span class="co"># np.array</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            Operator.O_F: [<span class="st">'final_state'</span>]})           <span class="co"># np.array</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> instance.reuse_instance():</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin F_INIT</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        t_max <span class="op">=</span> instance.get_setting(<span class="st">'t_max'</span>, <span class="st">'float'</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        dt <span class="op">=</span> instance.get_setting(<span class="st">'dt'</span>, <span class="st">'float'</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> instance.get_setting(<span class="st">'k'</span>, <span class="st">'float'</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> initial_state</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        t_cur <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end F_INIT</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin state_update_loop</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        ...</span></code></pre>
</div>
<p>Note that getting settings needs to happen within the reuse loop; doing it before can lead to incorrect results.</p>
</div>
</div>
</div>
</div>
</section><section id="receiving-messages"><h2 class="section-heading">Receiving messages<a class="anchor" aria-label="anchor" href="#receiving-messages"></a>
</h2>
<hr class="half-width">
<p>Apart from settings, we can use the <code>Instance.receive</code> function to receive an initial state for this submodel on the <code>initial_state</code> port. Note that we have declared that port above, and declared it to be associated with the <code>F_INIT</code> operator. During <code>F_INIT</code>, messages can only be received, not sent, so that declaration makes <code>initial_state</code> a receiving port.</p>
<p>The message that we will receive can contain several pieces of information. For now, we are interested in the <code>data</code> and <code>timestamp</code> attributes. We assume the data to be a grid of floats containing our initial state and the time stamp tells us the simulated time at which this state is valid. We can receive a message and store the <code>data</code> and <code>timestamp</code> attributes in the following way:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    msg <span class="op">=</span> instance.receive(<span class="st">'initial_state'</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> msg.data.array.copy()</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    timestamp <span class="op">=</span> msg.timestamp</span></code></pre>
</div>
<div id="why-.copy-again" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="why-.copy-again" class="callout-inner">
<h3 class="callout-title">Why .copy() again?<a class="anchor" aria-label="anchor" href="#why-.copy-again"></a>
</h3>
<div class="callout-content">
<p>The <code>msg.data</code> attribute holds an object of type <code>libmuscle.Grid</code>, which holds a read-only NumPy array and optionally a list of index names. Here, we take the array and make a copy of it for <code>data</code>, so that we can modify <code>data</code> in our upcoming state update. Without calling <code>.copy()</code>, the variable <code>data</code> would end up pointing to the same read-only array, and we would get an error message if we tried to modify it.</p>
<p>The <code>timestamp</code> attribute is a double precision float containing the number of simulated (not wall-clock) seconds since the whole simulation started. Since <code>t_cur</code> is assigned the value of the timestamp, we don’t need to make a copy.</p>
</div>
</div>
</div>
</section><section id="state-update-loop"><h2 class="section-heading">State update loop<a class="anchor" aria-label="anchor" href="#state-update-loop"></a>
</h2>
<hr class="half-width">
<p>The actual state update happens in the operator <span class="math inline">\(S\)</span> in the Submodel Execution Loop and, in our example model, it is determined entirely by the current state. Since no information from outside is needed, we do not receive any messages, and in our <code>libmuscle.Instance</code> declaration above, we did not declare any ports associated with <code>Operator.S</code>.</p>
<p>The operator <code>O_I</code> provides for observations of intermediate states. In other words, here is where you can send a message to the outside world with (part of) the current state. In this case, the <code>O_I</code> operator is empty; we’re not sending anything.</p>
<p>One thing we need to be aware of is time. Most models depend on time in some way and it is good to be aware of the various time frames. Libmuscles messages support passing on timestamps to be able to keep track of the global simulation time of the coupled model. It is easier to keep track of only one time frame and it is therefore good practice to add the timestamp that accompanied the initial state to the sub-model simulation time steps instead of starting at zero for every sub-model instance.</p>
<div id="challenge-4-receiving-the-initial-state-and-keeping-track-of-time" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-receiving-the-initial-state-and-keeping-track-of-time" class="callout-inner">
<h3 class="callout-title">Challenge 4: Receiving the initial state and keeping track of time<a class="anchor" aria-label="anchor" href="#challenge-4-receiving-the-initial-state-and-keeping-track-of-time"></a>
</h3>
<div class="callout-content">
<p>Where previously we had received <code>initial_state</code> from the function call, we now want to get it through a libmuscle message. Add statements to receive a message on the <code>initial_state</code> port and store the <code>data</code> and <code>timestamp</code> attributes in an appropriate place.</p>
<p>Also make sure the state update loop tracks global simulation time (corrected by the received timestamp).</p>
</div>
</div>
</div>
<div id="accordionSolution5" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution5" aria-expanded="false" aria-controls="collapseSolution5">
  <h4 class="accordion-header" id="headingSolution5">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution5" class="accordion-collapse collapse" data-bs-parent="#accordionSolution5" aria-labelledby="headingSolution5">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle <span class="im">import</span> Instance</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ymmsl <span class="im">import</span> Operator</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reaction() <span class="op">-&gt;</span> np.array:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ...</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    instance <span class="op">=</span> Instance({</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            Operator.F_INIT: [<span class="st">'initial_state'</span>],       <span class="co"># np.array</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            Operator.O_F: [<span class="st">'final_state'</span>]})           <span class="co"># np.array</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> instance.reuse_instance():</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin F_INIT</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        t_max <span class="op">=</span> instance.get_setting(<span class="st">'t_max'</span>, <span class="st">'float'</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        dt <span class="op">=</span> instance.get_setting(<span class="st">'dt'</span>, <span class="st">'float'</span>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> instance.get_setting(<span class="st">'k'</span>, <span class="st">'float'</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> instance.receive(<span class="st">'initial_state'</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> msg.data.array.copy()</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        t_cur <span class="op">=</span> msg.timestamp</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        t_max <span class="op">=</span> msg.timestamp <span class="op">+</span> t_max</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end F_INIT</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin state_update_loop</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> t_cur <span class="op">+</span> dt <span class="op">&lt;</span> t_max:</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        ...</span></code></pre>
</div>
<div id="time-keeping" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="time-keeping" class="callout-inner">
<h3 class="callout-title">Time keeping<a class="anchor" aria-label="anchor" href="#time-keeping"></a>
</h3>
<div class="callout-content">
<p>Both <code>t_cur</code> and <code>t_max</code> used to be relative to the start of the submodel, but now represent absolute simulation time of the coupled system. The length of the while loop will not change, but in this way we would be able to send out the current global simulation time <code>t_cur</code> in the state update loop using the <code>I_O</code> operator. It is also possible to keep <code>t_cur</code> and <code>t_max</code> relative to the start of the submodel and only correct for the received global timestamp when you send out a message. It is often however preferable to keep track of only one single timeframe and make the corrections right at the receiving end.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</section><section id="sending-messages"><h2 class="section-heading">Sending messages<a class="anchor" aria-label="anchor" href="#sending-messages"></a>
</h2>
<hr class="half-width">
<p>To send a message we first have to construct a <code>libmuscle.Message</code> object containing the current simulation time and the current state. We will convert the <code>numpy.array</code> to a <code>libmuscle.Grid</code> object first.</p>
<div id="muscle-grids" class="callout callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="muscle-grids" class="callout-inner">
<h3 class="callout-title">MUSCLE grids<a class="anchor" aria-label="anchor" href="#muscle-grids"></a>
</h3>
<div class="callout-content">
<p>We convert our <code>numpy.array</code> explicitly into a <code>libmuscle.Grid object</code>, so that we can add the name of the dimensions. In our example case there is only one, and “x” is not very descriptive, so we could have also passed the array directly, in which case MUSCLE would have done the conversion for us and sent a <code>libmuscle.Grid</code> without index names automatically.</p>
</div>
</div>
</div>
<p>The optional second parameter is a second timestamp, which is only used in <a href="https://muscle3.readthedocs.io/en/latest/tutorial.html#message-timestamps" class="external-link">more advanced applications</a> and can be set to <code>None</code> here.</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle <span class="im">import</span> Grid, Message</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>my_message <span class="op">=</span> Message(my_timestamp, <span class="va">None</span>, Grid(my_state, [<span class="st">'x'</span>]))</span></code></pre>
</div>
<p>To send the message, we specify the port on which to send, which needs to match the name of a port specified when we created the <code>Instance</code> object:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>instance.send(<span class="st">'final_state'</span>, final_message)</span></code></pre>
</div>
<div id="challenge-5-send-back-the-result" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-5-send-back-the-result" class="callout-inner">
<h3 class="callout-title">Challenge 5: Send back the result<a class="anchor" aria-label="anchor" href="#challenge-5-send-back-the-result"></a>
</h3>
<div class="callout-content">
<p>In the <span class="math inline">\(O_f\)</span> operator of your model construct a message and replace the return statement with a call to <code>libmuscle.Instance.send()</code> to send the final state to the outside world.</p>
</div>
</div>
</div>
<div id="accordionSolution6" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution6" aria-expanded="false" aria-controls="collapseSolution6">
  <h4 class="accordion-header" id="headingSolution6">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution6" class="accordion-collapse collapse" data-bs-parent="#accordionSolution6" aria-labelledby="headingSolution6">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle <span class="im">import</span> Instance, Grid, Message</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ymmsl <span class="im">import</span> Operator</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reaction():</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    ...</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    instance <span class="op">=</span> Instance({</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            Operator.F_INIT: [<span class="st">'initial_state'</span>],       <span class="co"># np.array</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            Operator.O_F: [<span class="st">'final_state'</span>]})           <span class="co"># np.array</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> instance.reuse_instance():</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin F_INIT</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        t_max <span class="op">=</span> instance.get_setting(<span class="st">'t_max'</span>, <span class="st">'float'</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        dt <span class="op">=</span> instance.get_setting(<span class="st">'dt'</span>, <span class="st">'float'</span>)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> instance.get_setting(<span class="st">'k'</span>, <span class="st">'float'</span>)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">=</span> instance.receive(<span class="st">'initial_state'</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> msg.data.array.copy()</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        t_cur <span class="op">=</span> msg.timestamp</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        t_max <span class="op">=</span> msg.timestamp <span class="op">+</span> t_max</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end F_INIT</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin state_update_loop</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> t_cur <span class="op">+</span> dt <span class="op">&lt;</span> t_max:</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># begin O_I</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># end O_I</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>            <span class="co"># begin S</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> k <span class="op">*</span> U <span class="op">*</span> dt</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>            t_cur <span class="op">+=</span> dt</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># end S</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end state_update_loop</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># begin O_F</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>        final_message <span class="op">=</span> Message(t_cur, <span class="va">None</span>, Grid(U, [<span class="st">'x'</span>]))</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>        instance.send(<span class="st">'final_state'</span>, final_message)</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># end O_F</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Right now your sub-model is ready to be used by the muscle manager. We will couple it to another submodel and configure it to run the coupled simulation in the next chapter.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Keypoints<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>MUSCLE3 implements the MMSF theory, using the same terminology and MMSL for configuration of the coupled simulation</li>
<li>First analyze your code to find the Submodel Execution Loop structure</li>
<li>MUSCLE lets the submodels communicate through messages, containing model states and simulation times</li>
</ul>
</div>
</div>
</div>
<!-- 
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use. 
 -->
</section></section><section id="aio-04-muscle-couple"><p>Content from <a href="04-muscle-couple.html">MUSCLE3 - coupling and running</a></p>
<hr>
<p> Last updated on 2022-10-31 | 
        
        <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/edit/main/episodes/04-muscle-couple.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right"> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do you couple multiple sub-models using MUSCLE3?</li>
<li>How do you run a coupled simulation with MUSCLE3?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Demonstrate how MUSCLE3 implements the Multiscale Modelling and Simulation Language (MMSL)</li>
<li>Configure a coupled simulation with MUSCLE3</li>
<li>Run a coupled simulation using MUSCLE3</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>We managed to connect one of our sub-models, the reaction model, to MUSCLE. In order to make a coupled simulation, we need at least two models. The second model here is the diffusion model. We prepared it for you, adding the necessary MUSCLE bindings and comments similar to what we did for the reaction model. You can open it from <code>diffusion.py</code>.</p>
</section><section id="investigating-the-macro-model"><h2 class="section-heading">Investigating the macro model<a class="anchor" aria-label="anchor" href="#investigating-the-macro-model"></a>
</h2>
<hr class="half-width">
<div id="challenge-1-investigating-the-diffusion-model" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-1-investigating-the-diffusion-model" class="callout-inner">
<h3 class="callout-title">Challenge 1: Investigating the diffusion model<a class="anchor" aria-label="anchor" href="#challenge-1-investigating-the-diffusion-model"></a>
</h3>
<div class="callout-content">
<p>The <code>diffusion.py</code> file contains a couple of functions, as well as a few lines of code that may come in useful later. For now, let’s focus on the <code>diffusion</code> function.</p>
<ul>
<li>Compared to the <code>reaction</code> function you made previously, what is different, other than the mathematics of the model itself?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ul>
<li>The ports are named differently, and are attached to different operators</li>
<li>The send and receive statements are now within the state update loop</li>
</ul>
</div>
</div>
</div>
</div>
</section><section id="connecting-the-models-together"><h2 class="section-heading">Connecting the models together<a class="anchor" aria-label="anchor" href="#connecting-the-models-together"></a>
</h2>
<hr class="half-width">
<p>With both models defined, we now need to instruct MUSCLE3 on how to connect them together. Recall the gMMSL diagram from the previous episode (with port names, this time):</p>
<figure><img src="fig/ep04-reaction-diffusion-coupling.png" alt="gMMSL diagram for the reaction-diffusion model. Two boxes labeled macro and micro represent the two submodels. A line connects a filled circle labeled state_out on macro to an open diamond labeled state_in on micro. A second line connects a filled diamond labeled final_state on micro to an open circle labeled state_in on macro." class="figure mx-auto d-block"><figcaption>gMMSL diagram for the reaction-diffusion model</figcaption></figure><p>Since diagrams aren’t valid Python, we need an alternative way of describing this model in our code. For this, we will create a MUSCLE configuration file written in the yMMSL language. This file tells the MUSCLE manager about the existence of each submodel and how it should be connected to the other components.</p>
<div id="challenge-2-creating-the-ymmsl-file" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-2-creating-the-ymmsl-file" class="callout-inner">
<h3 class="callout-title">Challenge 2: Creating the yMMSL file<a class="anchor" aria-label="anchor" href="#challenge-2-creating-the-ymmsl-file"></a>
</h3>
<div class="callout-content">
<p>Open the file <code>reaction_diffusion.ymmsl</code>. In it, you’ll find an incomplete yMMSL description of the coupled simulation, as shown below. Your challenge? Complete it!</p>
<p>Tip: remember that this is a textual description of the diagram above. All the information you need is in there.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">YAML<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode yaml" tabindex="0"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ymmsl_version</span><span class="kw">:</span><span class="at"> v0.1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">model</span><span class="kw">:</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> reaction_diffusion</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">components</span><span class="kw">:</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">macro</span><span class="kw">:</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">implementation</span><span class="kw">:</span><span class="at"> diffusion</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">o_i</span><span class="kw">:</span><span class="at"> state_out</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="at">        ...</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="at">    ...</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">implementation</span><span class="kw">:</span><span class="at"> reaction</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="at">      ...</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">conduits</span><span class="kw">:</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">macro.state_out</span><span class="kw">:</span><span class="at"> micro.initial_state</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="at">    ...</span></span></code></pre>
</div>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">YAML<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode yaml" tabindex="0"><code class="sourceCode yaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ymmsl_version</span><span class="kw">:</span><span class="at"> v0.1</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">model</span><span class="kw">:</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> reaction_diffusion_python</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">components</span><span class="kw">:</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">macro</span><span class="kw">:</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">implementation</span><span class="kw">:</span><span class="at"> diffusion</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">o_i</span><span class="kw">:</span><span class="at"> state_out</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">s</span><span class="kw">:</span><span class="at"> state_in</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">micro</span><span class="kw">:</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">implementation</span><span class="kw">:</span><span class="at"> reaction</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">f_init</span><span class="kw">:</span><span class="at"> initial_state</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">o_f</span><span class="kw">:</span><span class="at"> final_state</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">conduits</span><span class="kw">:</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">macro.state_out</span><span class="kw">:</span><span class="at"> micro.initial_state</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">micro.final_state</span><span class="kw">:</span><span class="at"> macro.state_in</span></span></code></pre>
</div>
<p>First, we describe the two components in this model. Components can be submodels, or helper components that convert data, control the simulation, or otherwise implement required non-model functionality. The name of a component is used by MUSCLE as an address for communication between the models. The implementation name is intended for use by a launcher, which would start the corresponding program to create an instance of a component. It is these instances that form the actual running simulation. In this example, we have two submodels: one named macro and one named micro. Macro is implemented by an implementation named diffusion, while micro is implemented by an implementation named reaction.</p>
<p>Second, we need to connect the components together. This is done by conduits, which have a sender and a receiver. Here, we connect sending port <code>state_out</code> on component <code>macro</code> to receiving port <code>initial_state</code> on component <code>micro</code>.</p>
</div>
</div>
</div>
</div>
</section><section id="adding-settings"><h2 class="section-heading">Adding settings<a class="anchor" aria-label="anchor" href="#adding-settings"></a>
</h2>
<hr class="half-width">
<p>The above specifies which submodels we have and how they are connected together. Next, we need to configure them by adding the settings to the yMMSL file. These will be passed to the models, who get them using the <code>Instance.get_settings()</code> function. Go ahead and add them to your <code>reaction_diffusion.ymmsl</code>:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">YAML<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode yaml" tabindex="0"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">settings</span><span class="kw">:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">micro.t_max</span><span class="kw">:</span><span class="at"> </span><span class="fl">2.469136e-6</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">micro.dt</span><span class="kw">:</span><span class="at"> </span><span class="fl">2.469136e-8</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">macro.t_max</span><span class="kw">:</span><span class="at"> </span><span class="fl">1.234568e-4</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">macro.dt</span><span class="kw">:</span><span class="at"> </span><span class="fl">2.469136e-6</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">x_max</span><span class="kw">:</span><span class="at"> </span><span class="fl">1.01</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">dx</span><span class="kw">:</span><span class="at"> </span><span class="fl">0.01</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">k</span><span class="kw">:</span><span class="at"> </span><span class="fl">-4.05e4</span><span class="co">    # reaction parameter</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">d</span><span class="kw">:</span><span class="at"> </span><span class="fl">4.05e-2</span><span class="co">    # diffusion parameter</span></span></code></pre>
</div>
<p>Look at the names of the settings. Does anything stand out to you?</p>
</section><section id="specifying-resources"><h2 class="section-heading">Specifying resources<a class="anchor" aria-label="anchor" href="#specifying-resources"></a>
</h2>
<hr class="half-width">
<p>Finally, we need to tell MUSCLE3 whether and if so how each model is parallelised, so that it can reserve adequate resources for each component. In this case, the models are single-threaded so that is what we specify. Again, add this to your file.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">YAML<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode yaml" tabindex="0"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">resources</span><span class="kw">:</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">macro</span><span class="kw">:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">threads</span><span class="kw">:</span><span class="at"> </span><span class="dv">1</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">micro</span><span class="kw">:</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">threads</span><span class="kw">:</span><span class="at"> </span><span class="dv">1</span></span></code></pre>
</div>
<p>Note that we specify resources for each component, not for each implementation.</p>
</section><section id="launching-the-simulation"><h2 class="section-heading">Launching the simulation<a class="anchor" aria-label="anchor" href="#launching-the-simulation"></a>
</h2>
<hr class="half-width">
<p>This gives us all the pieces needed to construct a coupled simulation. All we need is the two model functions and the configuration, then we can connect them together and run the whole thing. The model functions we can import from the files we saw before:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diffusion <span class="im">import</span> diffusion</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> reaction <span class="im">import</span> reaction</span></code></pre>
</div>
<p>To load the configuration, we use the <code>load()</code> function from the <code>ymmsl</code> module that comes with MUSCLE3:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ymmsl</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>configuration <span class="op">=</span> ymmsl.load(Path(<span class="st">'reaction_diffusion.ymmsl'</span>))</span></code></pre>
</div>
<p>Finally, we need to create a connection from the names of the implementations listed in the yMMSL file to the Python functions that are those implementations:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>implementations <span class="op">=</span> {<span class="st">'reaction'</span>: reaction, <span class="st">'diffusion'</span>: diffusion}</span></code></pre>
</div>
<p>And then we can ask MUSCLE3 to start the coupled simulation:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> libmuscle.runner <span class="im">import</span> run_simulation.</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>run_simulation(configuration, implementations)</span></code></pre>
</div>
<p>You will find a <code>coupled_model.py</code> file with the others, which implements the above. It also configures Python’s logging subsystem to give us a bit more log output.</p>
<div id="challenge-3-running-the-coupled-simulation" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-3-running-the-coupled-simulation" class="callout-inner">
<h3 class="callout-title">Challenge 3: Running the coupled simulation<a class="anchor" aria-label="anchor" href="#challenge-3-running-the-coupled-simulation"></a>
</h3>
<div class="callout-content">
<p>If you haven’t already done so, add the settings and resources to your <code>reaction_diffusion.ymmsl</code>. Then, have a look at the <code>coupled_model.py</code> script and see if you can run it. It should show a plot on the screen showing the concentration over time. If not, try to find the problem! You should have a <code>muscle_manager.log</code> file, and maybe a <code>muscle3.micro.log</code> and <code>muscle3.macro.log</code> to help you figure out what went wrong.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<p>$ python3 coupled_model.py</p>
</div>
</div>
</div>
</div>
</section><section id="running-separate-programs-using-the-muscle3-manager"><h2 class="section-heading">Running separate programs using the MUSCLE3 manager<a class="anchor" aria-label="anchor" href="#running-separate-programs-using-the-muscle3-manager"></a>
</h2>
<hr class="half-width">
<p>The above <code>coupled_model.py</code> script imports the models as Python functions, and then starts them using MUSCLE3’s <code>runner.run_simulation()</code> function. This works great for models consisting entirely of Python components, and which are small enough to run on the local machine. However, models written in other languages like C++ or Fortran cannot be imported as Python functions, and larger simulations may need to run on many nodes on an HPC cluster. For such simulations, we cannot use <code>run_simulation()</code>, and we need to use the MUSCLE3 <em>manager</em> instead.</p>
<p>The MUSCLE3 manager, like the runner, gets a model description and a list of implementations to use, and then starts each required instance by starting its implementation. That’s a fair bit of new terminology, so here is what those words mean:</p>
<dl>
<dt>Component</dt>
<dd>Represents a simulated process with a domain and a scale, or is a helper component. One box in the gMMSL diagram. May have a single instance, or multiple instances e.g. in case of spatial scale separation or if it’s part of a UQ ensemble.
</dd>
<dt>Instance</dt>
<dd>A running program simulating a particular component. This may be a parallel program running on many cores or across many machines, or in could be a simple Python script.
</dd>
<dt>Implementation</dt>
<dd>A computer program (e.g. a Python script) that can be started to create an instance.
</dd>
</dl>
<div id="challenge-4-running-using-the-manager" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="challenge-4-running-using-the-manager" class="callout-inner">
<h3 class="callout-title">Challenge 4: Running using the manager<a class="anchor" aria-label="anchor" href="#challenge-4-running-using-the-manager"></a>
</h3>
<div class="callout-content">
<p>In this final challenge, we’ll run the reaction-diffusion model using the MUSCLE3 manager. This takes three steps: turning the reaction model into a stand-alone program, telling the manager how to start the programs, and finally running it all.</p>
<div class="section level3">
<h3 id="create-a-stand-alone-python-program">Create a stand-alone Python program<a class="anchor" aria-label="anchor" href="#create-a-stand-alone-python-program"></a>
</h3>
<p>First, you need to turn <code>reaction.py</code> into a stand-alone Python program.</p>
<p>Hint: Look at <code>diffusion.py</code>, which is already set up to do this. You can copy-paste and adapt from there.</p>
</div>
<div class="section level3">
<h3 id="add-an-implementations-section">Add an implementations section<a class="anchor" aria-label="anchor" href="#add-an-implementations-section"></a>
</h3>
<p>Next, you need to add an <code>implementations:</code> section to your yMMSL file. The implementations section describes which implementations are available to run. Here’s a template for a Python program:</p>
<pre><code>implementations:
  &lt;implementation_name&gt;:
    virtual_env: &lt;absolute path to virtual env to load&gt;
    executable: python
    args: &lt;absolute path to Python script&gt;</code></pre>
<p>Add this section to your <code>reaction_diffusion.ymmsl</code>, and replace all the items in angle brackets with the correct values.</p>
</div>
<div class="section level3">
<h3 id="run-the-simulation">Run the simulation<a class="anchor" aria-label="anchor" href="#run-the-simulation"></a>
</h3>
<p>To run the simulation using the manager, open a terminal and activate the virtual environment in which you’ve installed MUSCLE3. You can then start the simulation using <code>muscle_manager --start-all reaction_diffusion.ymmsl</code>. Do that, and inspect the output!</p>
</div>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4">
  Show me the solution
  </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<p>To turn <code>reaction.py</code> into a stand-alone program, you need to add the final section of <code>diffusion.py</code> to the end, slightly modified:</p>
<pre><code>if __name__ == '__main__':
    logging.basicConfig()
    logging.getLogger().setLevel(logging.INFO)
    reaction()</code></pre>
<p>The yMMSL file then gets an implementations section like this:</p>
<pre><code>implementations:
  reaction:
    virtual_env: /path/to/workdir/env
    executable: python
    args: /path/to/workdir/reaction.py

  diffusion:
    virtual_env: /path/to/workdir/env
    executable: python
    args: /path/to/workdir/diffusion.py</code></pre>
<p>Then, you can run using</p>
<pre><code>(env) $ muscle_manager --start-all reaction_diffusion.ymmsl</code></pre>
<p>And that will create a directory named <code>run_reaction_diffusion_&lt;date&gt;_&lt;time&gt;</code> with all the log files and model output neatly organised.</p>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Keypoints<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Models may differ in which ports they have and when they send and receive</li>
<li>The yMMSL file discribes components, conduits, settings and resources</li>
<li>Running the coupled simulation can be done from a Python script</li>
<li>For larger simulations and C++ and Fortran, submodels run as separate programs via the MUSCLE3 manager</li>
</ul>
</div>
</div>
</div>
<!-- 
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use. 
 -->
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
				<p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>
        
        <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/edit/main/README.md" class="external-link">Edit on GitHub</a>
        
	
        | <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a> 
        | <a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/" class="external-link">Source</a></p>
				<p><a href="https://github.com/esciencecenter-digital-skills/lesson-model-coupling/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:training@esciencecenter.nl">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">
        
        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>
        
        <p><a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">Template licensed under CC-BY 4.0</a> by <a href="https://carpentries.org" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper" class="external-link">sandpaper (0.12.5)</a>,
        <a href="https://github.com/carpentries/pegboard/tree/0.5.3" class="external-link">pegboard (0.5.3)</a>,
      and <a href="https://github.com/carpentries/varnish/tree/0.2.17" class="external-link">varnish (0.2.17)</a>.</p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
			<i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back to top"></i><br><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://esciencecenter-digital-skills.github.io/lesson-model-coupling/aio.html",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "multiscale, modeling, simulation, coupling, multiphyiscs",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://esciencecenter-digital-skills.github.io/lesson-model-coupling/aio.html",
  "identifier": "https://esciencecenter-digital-skills.github.io/lesson-model-coupling/aio.html",
  "dateCreated": "2022-08-16",
  "dateModified": "2023-08-15",
  "datePublished": "2023-08-15"
}

  </script><script>
		feather.replace();
	</script><!-- Matomo
    2022-11-07: we have gotten a notification that we have an overage for our
    tracking and I'm pretty sure this has to do with Workbench usage.
    Considering that I am not _currently_ using this tracking because I do not
    yet know how to access the data, I am turning this off for now.
  <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(["setDocumentTitle", document.domain + "/" + document.title]);
    _paq.push(["setDomains", ["*.preview.carpentries.org","*.datacarpentry.github.io","*.datacarpentry.org","*.librarycarpentry.github.io","*.librarycarpentry.org","*.swcarpentry.github.io", "*.carpentries.github.io"]]);
    _paq.push(["setDoNotTrack", true]);
    _paq.push(["disableCookies"]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
          var u="https://carpentries.matomo.cloud/";
          _paq.push(['setTrackerUrl', u+'matomo.php']);
          _paq.push(['setSiteId', '1']);
          var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
          g.async=true; g.src='https://cdn.matomo.cloud/carpentries.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g,s);
        })();
  </script>
  End Matomo Code -->
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

